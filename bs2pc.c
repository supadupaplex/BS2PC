#pragma warning(disable : 4996)

/*
Copyright (C) 1996-1997 Id Software, Inc.
Copyright (C) 2017 Triang3l

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

// This info is autogenerated during make and placed in buildinfo.c
extern const char *build_info;

#include "bs2pc.h"
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

bool bs2pc_errors = false;

// [SDP] fix #6: config
bool bs2pc_doMergeStrips = true;
bool bs2pc_doPolyDiv = true;
float bs2pc_polyDivSz = 8.0f;
bool bs2pc_szReport = false;
bool bs2pc_wadOnly = false;
bool bs2pc_noResize = false;
bool bs2pc_dryRun = false;

#define INFO_STR	"\
\n\
=== .bsp to .bs2 conversion fix by Supadupaplex ===\n\
\n\
Fixes list:\n\
1. increased subdivisions and vertices count caps\n\
2. qsort WAD lumps: fix crashing on some WADs\n\
3. slow texture lump iteration: fix animated textures\n\
4. prefer WAD texture sizes over sizes stored in bsp: scaling artifacts can\n\
   be avoided if WAD textures are manually resized to match power of 2\n\
5. calculate bs2 texture lump size based on WAD texture sizes\n\
6. added options: -nomerge, -szreport, -wadonly\n\
7. give warning if bs2 map file is too big\n\
8. added options: -noresize, -dryrun\n\
9. fixed '{' textures brightness\n\
10. ability to tweak subdivision with -divsz or to disable it with -nodiv\n\
\n\
Usage: bs2pc [-game \"path to base WAD directory for .bsp to .bs2\"]\n\
    [-game \"path to mod WAD directory\"] \"source file\" [\"target file\"]\n\
    [-szreport] [-wadonly] [-dryrun] [-nomerge] [-nodiv] [-divsz X]\n\
    [-noresize]\n\
-nodiv    - [bsp to bs2] omit subdivision step. This option can reduce map\n\
    RAM overhead and also improve performance a bit, especially on maps with\n\
    giant water surfaces. Waves can look weird though, you may need to set\n\
    \"WaveHeight\" to 0 in the entity properties\n\
-divsz    - [bsp to bs2] set subdivision size (default is 8). By increasing\n\
    this parameter you can reduce number of subdivisions and thus to get\n\
    benefits of -nodiv option up to a certain degree\n\
-nomerge  - [bsp to bs2] skip BS2PC_MergeStrips func, suggested by Triang3l:\n\
    \"this function is unfinished. In this state it can bring\n\
    performance boost but it also can cause glitches on water\n\
    and transparent surfaces\"\n\
-szreport - [bsp to bs2] report map file lump sizes\n\
-wadonly  - [all] load textures from WAD files only, ignore textures stored\n\
    directly in bsp/bs2 files\n\
-noresize - [bs2 to bsp] skip resizing textures - (!) breaks maps, useful\n\
    for PS2 texture harvesting only\n\
-dryrun   - [all] skip write to output file (might be useful for\n\
    troubleshooting or lump sizes inspection)\n\
"

int main(int argc, const char * const *argv) {
	int argi;
	bool parsingGame = false;
	bool parsingDivSz = false;
	const char *sourceFileName = NULL, *targetFileName = NULL;
	unsigned char *sourceFile;
	unsigned int sourceFileSize;
	unsigned int beginning;
	size_t targetFileNameLength;
	char *targetFileNameBuffer;

	fputs("BS2PC build 3 - Half-Life PlayStation 2 map converter.\n", stderr);
	fputs(build_info, stderr);
	for (argi = 1; argi < argc; ++argi) {
		const char *arg = argv[argi];
		if (parsingGame) {
			BS2PC_AddWadDirectory(arg);
			parsingGame = false;
		} else if (parsingDivSz) {
			parsingDivSz = false;
			bs2pc_polyDivSz = atof(arg);
			if (bs2pc_polyDivSz < 1.0f)
				bs2pc_polyDivSz = 1.0f;
			fprintf(stderr, "> Subdivision size was set to: %f\n", bs2pc_polyDivSz);
		} else {
			if (bs2pc_strcasecmp(arg, "-game") == 0) {
				parsingGame = true;
			} else if (bs2pc_strcasecmp(arg, "-nomerge") == 0) {
				/* [SDP] fix #6: skip BS2PC_MergeStrips() function call as
				 * it was suggested by Triang3l
				 */
				bs2pc_doMergeStrips = false;
				fputs("> Strip merging is disabled\n", stderr);
			} else if (bs2pc_strcasecmp(arg, "-divsz") == 0) {
				// [SDP] fix #10: customize subdivision size
				parsingDivSz = true;
			} else if (bs2pc_strcasecmp(arg, "-nodiv") == 0) {
				// [SDP] fix #10: omit subdivision step
				bs2pc_doPolyDiv = false;
				bs2pc_doMergeStrips = false;
				fputs("> Subdivision and strip merging are disabled\n", stderr);
			} else if (bs2pc_strcasecmp(arg, "-szreport") == 0) {
				// [SDP] fix #6: report lump sizes
				bs2pc_szReport = true;
				fputs("> Lump sizes report enabled\n", stderr);
			} else if (bs2pc_strcasecmp(arg, "-wadonly") == 0) {
				// [SDP] fix #6: ignore textures baked in the map file
				bs2pc_wadOnly = true;
				fputs("> Forced WAD textures\n", stderr);
			} else if (bs2pc_strcasecmp(arg, "-noresize") == 0) {
				/* [SDP] fix #8: don't resize textures when converting
				 * bs2 to bsp (useful for PS2 texture harvesting only)
				 */
				bs2pc_noResize = true;
				fputs("> Skip texture resize\n", stderr);
			} else if (bs2pc_strcasecmp(arg, "-dryrun") == 0) {
				// [SDP] fix #8: dry run
				bs2pc_dryRun = true;
				fputs("> Skip write to output file\n", stderr);
			} else if (arg[0] == '-') {
				fprintf(stderr, "> Bad argument: %s\n", arg);
				exit(EXIT_FAILURE);
			} else if (targetFileName == NULL) {
				if (sourceFileName != NULL) {
					targetFileName = arg;
				} else {
					sourceFileName = arg;
				}
			}
		}
	}
	if (sourceFileName == NULL) {
		fputs(INFO_STR, stderr);
		return EXIT_FAILURE;
	}

	fprintf(stderr, "Loading the source file: %s\n", sourceFileName);
	sourceFile = (unsigned char *) BS2PC_LoadFile(sourceFileName, &sourceFileSize);
	if (sourceFileSize <= sizeof(unsigned int)) {
		fputs("Source file size is invalid.\n", stderr);
		return EXIT_FAILURE;
	}

	beginning = *((const unsigned int *) sourceFile);

	if (beginning == BSPVERSION_ID) {
		void *targetFile;
		unsigned int targetFileSize;

		bs2pc_idMapSize = sourceFileSize;
		bs2pc_idMap = sourceFile;

		if (bs2pc_doPolyDiv)
			fputs("WARNING: .bsp to .bs2 is INCOMPLETE!\n"
			      "\t Polygon subdivision is broken! \n"
			      "\t DO NOT share any PS2 maps produced by this build!\n"
			      "\t [!] Check out -nomerge, -nodiv and -divsz options\n",
			      stderr);
		else
			fputs("WARNING: subdivision is disabled. Water waves can look\n"
			      "\t weird, you may need to set \"WaveHeight\" to 0 disable"
			      "\t the waves\n", stderr);
		BS2PC_ConvertIdToGbx();

		fputs("Compressing .bs2...\n", stderr);
		targetFile = BS2PC_CompressWithSize(bs2pc_gbxMap, bs2pc_gbxMapSize, &targetFileSize);

		if (bs2pc_dryRun) {
			fputs("Skip writing the .bs2 file.\n", stderr);
			goto exit;
		}

		fputs("Writing the .bs2 file...\n", stderr);
		if (targetFileName == NULL) {
			targetFileNameLength = strlen(sourceFileName);
			targetFileNameBuffer = bs2pc_alloca(targetFileNameLength + 5);
			strcpy(targetFileNameBuffer, sourceFileName);
			if (targetFileNameLength >= 4 && bs2pc_strcasecmp(targetFileNameBuffer + targetFileNameLength - 4, ".bsp") == 0) {
				targetFileNameBuffer[targetFileNameLength - 1] = '2';
			} else {
				strcpy(targetFileNameBuffer + targetFileNameLength, ".bs2");
			}
			targetFileName = targetFileNameBuffer;
		}
		BS2PC_WriteFile(targetFileName, targetFile, targetFileSize);

		fprintf(stderr, "%s converted to %s.\n", sourceFileName, targetFileName);
	} else {
		if (beginning != BSPVERSION_GBX) {
			fputs("Decompressing .bs2...\n", stderr);
			bs2pc_gbxMapSize = beginning;
			bs2pc_gbxMap = (unsigned char *) BS2PC_Alloc(bs2pc_gbxMapSize, false);
			BS2PC_Decompress(sourceFile + sizeof(unsigned int), sourceFileSize - sizeof(unsigned int), bs2pc_gbxMap, bs2pc_gbxMapSize);
			BS2PC_Free(sourceFile);
			sourceFile = NULL;
		} else {
			bs2pc_gbxMapSize = sourceFileSize;
			bs2pc_gbxMap = sourceFile;
		}

		BS2PC_ConvertGbxToId();

		if (bs2pc_dryRun) {
			fputs("Skip writing the .bsp file.\n", stderr);
			goto exit;
		}

		fputs("Writing the .bsp file...\n", stderr);
		if (targetFileName == NULL) {
			targetFileNameLength = strlen(sourceFileName);
			targetFileNameBuffer = bs2pc_alloca(targetFileNameLength + 5);
			strcpy(targetFileNameBuffer, sourceFileName);
			if (targetFileNameLength >= 4 && bs2pc_strcasecmp(targetFileNameBuffer + targetFileNameLength - 4, ".bs2") == 0) {
				targetFileNameBuffer[targetFileNameLength - 1] = (targetFileNameBuffer[targetFileNameLength - 3] == 'B' ? 'P' : 'p');
			} else {
				strcpy(targetFileNameBuffer + targetFileNameLength, ".bsp");
			}
			targetFileName = targetFileNameBuffer;
		}
		BS2PC_WriteFile(targetFileName, bs2pc_idMap, bs2pc_idMapSize);

		fprintf(stderr, "%s converted to %s.\n", sourceFileName, targetFileName);
	}

exit:
	// [SDP] change exit code if errors occured
	if (bs2pc_errors)
		return EXIT_FAILURE;

	return EXIT_SUCCESS;
}